**开篇至理名言:技术不能只关注零散的技术点，要建立起一套完整的知识框架，建立系统观是至关重要的！从某种程度上说，在解决问题时，拥有了系统观，就意味着你能有依据、有章法地定位和解决问题。**

## redis知识全景图

![redis知识全景图](https://gitee.com/wade_home/geek-xiaomage-note/raw/main/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/redis%E5%85%AC%E5%BC%80%E8%AF%BE%E7%AC%94%E8%AE%B0/img/redis%E7%9F%A5%E8%AF%86%E5%85%A8%E6%99%AF%E5%9B%BE.jpg)

## Redis问题原因图

![redis问题原因图](https://gitee.com/wade_home/geek-xiaomage-note/raw/main/其他笔记/redis公开课笔记/img/redis问题原因图.jpeg)



# 一、基本架构---一个key-value数据库包含什么
## 1．首先就要考虑里面可以存什么样的数据，对数据可以做什么样的操作，也就是数据模型和操作接口
（**1）可以存储那些数据？**
	Redis支持的 value 类型包括了 String、哈希表、列表、集合等。Redis能够在实际业务场景中得到广泛的应用，就是得益于支持多样化类型的 value。
**（2）可以对数据做什么操作？**
	**PUT**：新写入或更新一个 key-value 对；
	**GET**：根据一个 key 读取相应的 value 值；
	**DELETE**：根据一个 key 删除整个 key-value 对；
	**SET**：有些键值数据库的新写 / 更新操作叫 SET,新写入和更新虽然是用一个操作接口，但在实际执行时，会根据 key 是否存在而执行相应的新写或更新流程；
	**SCAN**：查询一个用户在一段时间内的访问记录。这种操作在键值数据库中属于 SCAN 操作，即根据一段 key 的范围返回相应的 value 值。
**（3）键值对保存在内存还是外存？**
	**保存在内存**：好处是读写很快，毕竟内存的访问速度一般都在百 ns 级别。但是，潜在的风险是一旦掉电，所有的数据都会丢失。
	**保存在外存**：虽然可以避免数据丢失，但是受限于磁盘的慢速读写（通常在几 ms 级别），键值数据库的整体性能会被拉低。
	**所以设计场景**：如何进行设计选择，我们通常需要考虑键值数据库的主要应用场景
**（4）一般的键值数据库包含的四部分**	
	**访问框架、索引模块、操作模块和存储模块**
	![键值数据库包含的四部分](https://gitee.com/wade_home/geek-xiaomage-note/raw/main/其他笔记/redis公开课笔记/img/键值数据库包含组件.jpg)
**（5）采用什么样的访问模式**
	**一般有两种:**
		**一种是通过函数库调用的方式供外部应用使用**，比如，上图中的 libsimplekv.so，就是以动态链接库的形式链接到我们自己的程序中，提供键值存储功能；如RocksDB
		**另一种是通过网络框架以 Socket 通信的形式对外提供键值对操作，这种形式可以提供广泛的键值存储服务**。
		在上图中，我们可以看到，网络框架中包括 Socket Server 和协议解析。如：Memcached 和 Redis

**（6）如何定位键值对的位置？**	
	当 Redis客户端发来的请求，知道了要进行的键值对操作，此时，Redis需要查找所要操作的键值对是否存在，这依赖于键值数据库的索引模块。**索引的作用是让键值数据库根据 key 找到相应 value 的存储位置，进而执行操作。**

   **索引效率方面**：内存键值数据库（例如 Redis）采用哈希表作为索引，很大一部分原因在于，其键值数据基本都是保存在内存中的，而内存的高性能随机访问特性可以很好地与哈希表 O(1) 的操作复杂度相匹配。

​	**问题：**Redis 而言，很有意思的一点是，它的 value 支持多种类型，当我们通过索引找到一个 key 所对应的 value 后，仍然需要从 value 的复杂结构（例如集合和列表）中进一步找到我们实际需要的数据，这个操作的效率本身就依赖于它们的实现结构；

Redis 采用一些常见的高效索引结构作为某些 value 类型的底层数据结构，这一技术路线为 Redis 实现高性能访问提供了良好的支撑

**（7）不同操作的具体逻辑是怎样的？**

​	对于 GET/SCAN 操作而言，此时根据 value 的存储位置返回 value 值即可；

​	对于 PUT 一个新的键值对数据而言，SimpleKV 需要为该键值对分配内存空间；

​	对于 DELETE 操作，SimpleKV 需要删除键值对，并释放相应的内存空间，这个过程由分配器完成。

​	**注意:对于写操作，除了产生新的键值对和删除键值对外，还需要分配和释放内存**

**（8）如何实现重启后快速提供服务？**

​	**内存分配器:**键值数据库的键值对通常大小不一，glibc 的分配器在处理随机的大小内存块分配时，表现并不好。一旦保存的键值对数据规模过大，就可能会造成较严重的内存碎片问题。Redis 的内存分配器提供了多种选择，分配效率也不一样，后面我会具体讲一讲这个问题。

​	**持久化机制：**就是为了保证重启后快速提供服务而设计的。持久化方式有两种，各有良莠：

​		一种方式是，对于**每一个键值对，SimpleKV 都对其进行落盘保存**，这虽然让 SimpleKV 的数据更加可靠，但是，因为每次都要写盘，SimpleKV 的性能会受到很大影响。

​		另一种方式是，SimpleKV 只是**周期性地把内存中的键值数据保存到文件中**，这样可以避免频繁写盘操作的性能影响。但是，一个潜在的代价是 SimpleKV 的数据仍然有丢失的风险。

## 小结

**1.前面两部是通过业务进行驱动是设计，后面是根据业务，一级内存数据库所有内部构造。**

**2.Redis则是比上述设计更为复杂，且更为贴近实际业务场景的一款软件，主要区别如下**

![](https://gitee.com/wade_home/geek-xiaomage-note/raw/main/其他笔记/redis公开课笔记/img/SimpleKV和Redis的区别.jpg)

* Redis 主要通过网络框架进行访问，而不再是动态库了，这也使得 Redis 可以作为一个基础性的网络服务进行访问，扩大了 Redis 的应用范围。

* Redis 数据模型中的 value 类型很丰富，因此也带来了更多的操作接口，例如面向列表的 LPUSH/LPOP，面向集合的 SADD/SREM 等。在下节课，我将和你聊聊这些 value 模型背后的数据结构和操作效率，以及它们对 Redis 性能的影响。

* Redis 的持久化模块能支持两种方式：日志（AOF）和快照（RDB），这两种持久化方式具有不同的优劣势，影响到 Redis 的访问性能和可靠性。

* SimpleKV 是个简单的单机键值数据库，但是，Redis 支持高可靠集群和高可扩展集群，因此，Redis 中包含了相应的集群功能支撑模块。

  # 二、数据结构：快速的Redis有哪些慢操作？

  ## 1.Redis为何能快速的找到数据？

  ​	**两点原因:** 

  *  在内存中进行操作 

  * 高效的数据结构

  ## 2.Redis底层高效的内存数据结构

  简单来说，底层数据结构一共有 6 种，分别是**简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组**。它们和数据类型的对应关系如下图所示：

  图中上部分为redis键值对中值的保存形式；下部分为正真的底层数据结构；

  ![](https://gitee.com/wade_home/geek-xiaomage-note/raw/main/其他笔记/redis公开课笔记/img/redis底层数据结构.jpg)

可以看到，String 类型的底层实现只有一种数据结构，也就是简单动态字符串。而 List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构。通常情况下，我们会把这四种类型称为集合类型，它们的特点是一个键对应了一个集合的数据。